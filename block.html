<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <title>ABC Academy Blocks Breaker (Mobile Friendly)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a2e; /* Dark space blue */
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            color: #e0e0e0; /* Light grey text */
            overflow: hidden; /* Prevent scrollbars */
            /* Prevent pull-to-refresh and other touch gestures interfering */
            overscroll-behavior-y: contain;
        }

        .game-container {
            text-align: center;
            border: 5px solid #4a4e69; /* Darker purple-grey border */
            border-radius: 15px;
            padding: 15px; /* Slightly reduced padding */
            background-color: #162447; /* Deep blue background */
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Cyan glow */
            max-width: 95%; /* Ensure container doesn't overflow small screens */
            box-sizing: border-box;
        }

        h1 {
            color: #fca311; /* Orange title */
            margin-bottom: 5px;
            font-size: 1.3em; /* Adjusted font size */
        }

        .instagram-link {
            margin-bottom: 10px;
            font-size: 0.6em; /* Adjusted font size */
        }

        .instagram-link a {
            color: #00ffcc; /* Bright teal link */
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .instagram-link a:hover {
            color: #ffffff; /* White on hover */
        }


        #scoreBoard {
            font-size: 1em; /* Adjusted font size */
            margin-bottom: 10px; /* Adjusted margin */
            color: #00ffcc; /* Bright teal score */
        }

        canvas {
            background-color: #000; /* Black canvas background */
            display: block;
            border-radius: 10px;
            border: 3px solid #4a4e69;
            /* Make canvas responsive */
            max-width: 100%;
            height: auto;
            aspect-ratio: 480 / 320; /* Maintain aspect ratio */
            cursor: none; /* Hide cursor over canvas */
            touch-action: none; /* Prevent default touch actions like scrolling */
        }

        #messageBox {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(40, 40, 60, 0.9);
            color: #fff;
            padding: 20px; /* Adjusted padding */
            border-radius: 15px;
            border: 3px solid #fca311;
            text-align: center;
            display: none;
            z-index: 10;
            font-size: 1em; /* Adjusted font size */
            box-shadow: 0 0 15px rgba(255, 163, 17, 0.7);
            width: 80%; /* Make message box responsive */
            max-width: 300px;
        }

        #messageBox button {
            font-family: 'Press Start 2P', cursive;
            padding: 10px 15px; /* Adjusted padding */
            font-size: 0.9em; /* Adjusted font size */
            margin-top: 15px; /* Adjusted margin */
            cursor: pointer;
            background: linear-gradient(145deg, #fca311, #e85d04);
            color: #162447;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px #d35400;
            transition: all 0.1s ease;
        }

        #messageBox button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #d35400;
        }

    </style>
</head>
<body>
    <div class="game-container">
        <h1>ABC Academy</h1>
        <p class="instagram-link">
            <a href="https://www.instagram.com/saleh__zeer/" target="_blank" rel="noopener noreferrer">@saleh__zeer</a>
        </p>
        <div id="scoreBoard">Score: 0</div>
        <canvas id="gameCanvas" width="480" height="320"></canvas>
        <div id="messageBox">
            <p id="messageText"></p>
            <button id="restartButton">Play Again</button>
        </div>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreBoard = document.getElementById('scoreBoard');
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const restartButton = document.getElementById('restartButton');

            // --- Sound Synthesis Setup (Tone.js) ---
            let synth;
            let soundEnabled = false;

            function initAudio() {
                // Only initialize if not already enabled and context is not running
                if (!soundEnabled && Tone.context.state !== 'running') {
                    Tone.start().then(() => {
                        console.log("Audio Context started");
                        synth = new Tone.Synth({
                            oscillator: { type: 'square' },
                            envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 }
                        }).toDestination();
                        soundEnabled = true;
                    }).catch(e => console.error("Could not start Audio Context:", e));
                } else if (!synth && soundEnabled) { // If context started but synth creation failed/was delayed
                     synth = new Tone.Synth({
                            oscillator: { type: 'square' },
                            envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 }
                        }).toDestination();
                }
            }

            function playSound(note, duration = '16n', volume = 0) {
                if (!soundEnabled) initAudio(); // Try to init audio if needed
                if (synth && soundEnabled) {
                    try { synth.volume.value = volume; synth.triggerAttackRelease(note, duration); }
                    catch (e) { console.warn("Sound playback failed:", e); }
                }
            }

            // --- Game Variables ---
            let ballRadius = 8;
            let x, y;
            let dx, dy;
            const initialPaddleWidth = 75;
            const minPaddleWidth = 40;
            let paddleHeight = 10;
            let paddleWidth = initialPaddleWidth;
            let paddleX;
            let rightPressed = false;
            let leftPressed = false;
            let score = 0;
            let gameRunning = true;
            const maxBallSpeed = 6;
            const speedIncrement = 0.1;
            const paddleShrinkAmount = 1;

            // --- Brick Variables ---
            const brickRowCount = 3;
            const brickColumnCount = 5; // Increased columns for better fit
            let brickWidth; // Calculated dynamically
            let brickHeight = 20;
            let brickPadding; // Calculated dynamically
            let brickOffsetTop = 30;
            let brickOffsetLeft; // Calculated dynamically
            const words = ["This", "That", "Mother", "Father", "Three", "teeth", "Bath", "think", "Duck", "Rocket", "Queen", "Quilt", "noise"];
            let bricks = [];
            let wordIndex = 0;
            let totalBricks = 0;

            // --- Brick Colors ---
            const brickColor1Hit = "#ff8c00";
            const brickColor2HitInitial = "#a0522d";
            const brickColor2HitDamaged = "#cd853f";

            // Function to calculate brick layout based on canvas size
            function calculateBrickLayout() {
                const totalPaddingSpace = canvas.width * 0.15; // Use 15% of width for padding/offsets
                brickOffsetLeft = totalPaddingSpace / 2;
                const availableWidth = canvas.width - totalPaddingSpace;
                brickPadding = availableWidth / (brickColumnCount * 4); // Adjust padding calculation
                brickWidth = (availableWidth - (brickPadding * (brickColumnCount -1))) / brickColumnCount;

                 // Optional: Adjust brick height based on width for better aspect ratio
                 // brickHeight = brickWidth / 3.5;
            }


            // Initialize game elements
            function initGame() {
                calculateBrickLayout(); // Calculate layout first

                x = canvas.width / 2;
                y = canvas.height - 30;
                dx = 3;
                dy = -3;
                paddleWidth = initialPaddleWidth;
                paddleX = (canvas.width - paddleWidth) / 2;
                score = 0;
                wordIndex = 0;
                bricks = [];
                totalBricks = 0;
                gameRunning = true;
                messageBox.style.display = 'none';

                // Create bricks with calculated layout and varying hits
                for (let c = 0; c < brickColumnCount; c++) {
                    bricks[c] = [];
                    for (let r = 0; r < brickRowCount; r++) {
                        // Use calculated dimensions and offsets
                        const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        const word = words[wordIndex % words.length];
                        const hitsRequired = (c + r) % 2 === 0 ? 2 : 1;
                        bricks[c][r] = {
                            x: brickX, y: brickY, status: 1, word: word,
                            hitsRequired: hitsRequired, currentHits: 0
                        };
                        totalBricks += hitsRequired;
                        wordIndex++;
                    }
                }
                updateScore();
            }

            // --- Event Listeners ---
            // Mouse controls
            document.addEventListener("mousemove", handlePointerMove, false);
            // Touch controls
            document.addEventListener("touchstart", handlePointerStart, false);
            document.addEventListener("touchmove", handlePointerMove, false);
             // Keyboard controls
            document.addEventListener("keydown", keyDownHandler, false);
            document.addEventListener("keyup", keyUpHandler, false);
            // Audio initialization triggers
            document.addEventListener('click', initAudio, { once: true });
            document.addEventListener('keydown', initAudio, { once: true });
            document.addEventListener('touchstart', initAudio, { once: true }); // Init audio on touch
            // Restart button
            restartButton.addEventListener("click", () => {
                initGame();
                draw();
            });

            // --- Unified Pointer Handler (Mouse & Touch) ---
            function handlePointerStart(e) {
                 // Prevent default touch actions like scrolling/zooming
                e.preventDefault();
                // Initialize audio on first touch if needed
                if (!soundEnabled) initAudio();
                // Handle movement immediately on touch start
                handlePointerMove(e);
            }

            function handlePointerMove(e) {
                 // Prevent default touch actions like scrolling/zooming
                e.preventDefault();
                // Initialize audio on first move if needed (redundant if start handled it, but safe)
                if (!soundEnabled) initAudio();

                const rect = canvas.getBoundingClientRect();
                let clientX;

                // Check if it's a touch event
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                } else if (e.clientX) { // Check if it's a mouse event
                    clientX = e.clientX;
                } else {
                    return; // Exit if no valid pointer data
                }

                let relativeX = clientX - rect.left;
                // Scale relativeX based on canvas display size vs internal resolution
                relativeX *= canvas.width / rect.width;

                // Update paddle position, clamping within canvas bounds using current paddleWidth
                const halfPaddle = paddleWidth / 2;
                if (relativeX > halfPaddle && relativeX < canvas.width - halfPaddle) {
                    paddleX = relativeX - halfPaddle;
                } else if (relativeX <= halfPaddle) {
                    paddleX = 0; // Clamp to left edge
                } else {
                    paddleX = canvas.width - paddleWidth; // Clamp to right edge
                }
            }


            // --- Keyboard Control Handlers ---
            function keyDownHandler(e) {
                if (e.key == "Right" || e.key == "ArrowRight") rightPressed = true;
                else if (e.key == "Left" || e.key == "ArrowLeft") leftPressed = true;
            }

            function keyUpHandler(e) {
                if (e.key == "Right" || e.key == "ArrowRight") rightPressed = false;
                else if (e.key == "Left" || e.key == "ArrowLeft") leftPressed = false;
            }

            // --- Drawing Functions ---
            function drawBall() {
                ctx.beginPath();
                ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(x, y, ballRadius * 0.1, x, y, ballRadius);
                gradient.addColorStop(0, "#ffffff");
                gradient.addColorStop(0.7, "#00ffcc");
                gradient.addColorStop(1, "#00bfa5");
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.closePath();
            }

            function drawPaddle() {
                ctx.beginPath();
                ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
                const gradient = ctx.createLinearGradient(paddleX, canvas.height - paddleHeight, paddleX, canvas.height);
                gradient.addColorStop(0, "#fca311");
                gradient.addColorStop(1, "#e85d04");
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.closePath();
            }

            function drawBricks() {
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        const brick = bricks[c][r];
                        if (brick.status == 1) {
                            ctx.beginPath();
                            ctx.rect(brick.x, brick.y, brickWidth, brickHeight); // Use calculated width/height

                            let fillColor;
                            if (brick.hitsRequired === 1) fillColor = brickColor1Hit;
                            else fillColor = (brick.currentHits === 0) ? brickColor2HitInitial : brickColor2HitDamaged;
                            ctx.fillStyle = fillColor;
                            ctx.fill();
                            ctx.closePath();

                            // Draw word (adjust font size if bricks are very small)
                            const fontSize = Math.min(10, brickHeight * 0.5); // Dynamic font size based on brick height
                            ctx.font = `${fontSize}px 'Press Start 2P'`;
                            ctx.fillStyle = "#ffffff";
                            ctx.textAlign = "center";
                            const textX = brick.x + brickWidth / 2;
                            const textY = brick.y + brickHeight / 2 + (fontSize / 2.5); // Adjust vertical centering
                            ctx.fillText(brick.word, textX, textY);
                        }
                    }
                }
            }

            function updateScore() {
                scoreBoard.textContent = `Score: ${score}`;
            }

            // --- Collision Detection ---
            function collisionDetection() {
                for (let c = 0; c < brickColumnCount; c++) {
                    for (let r = 0; r < brickRowCount; r++) {
                        const b = bricks[c][r];
                        if (b.status == 1) {
                            // AABB Collision check
                            if (x + ballRadius > b.x && x - ballRadius < b.x + brickWidth &&
                                y + ballRadius > b.y && y - ballRadius < b.y + brickHeight)
                            {
                                dy = -dy;
                                b.currentHits++;

                                if (b.currentHits >= b.hitsRequired) {
                                    b.status = 0;
                                    score++;
                                    playSound('C5', '16n', -5);

                                    // Increase speed
                                    if (Math.abs(dx) < maxBallSpeed && Math.abs(dy) < maxBallSpeed) {
                                        dx += (dx > 0 ? speedIncrement : -speedIncrement);
                                        dy += (dy > 0 ? speedIncrement : -speedIncrement);
                                    }

                                    // Decrease paddle width
                                    if (paddleWidth > minPaddleWidth) {
                                        paddleWidth -= paddleShrinkAmount;
                                        // Ensure paddle doesn't go off-screen after resize
                                        if (paddleX + paddleWidth > canvas.width) {
                                            paddleX = canvas.width - paddleWidth;
                                        }
                                    }

                                    updateScore();

                                    // Check win condition
                                    if (score == totalBricks) {
                                        playSound('G5', '8n', 0);
                                        showEndGameMessage("YOU WIN, CONGRATS!");
                                    }
                                } else {
                                    playSound('A4', '32n', -15); // Damaged sound
                                }
                            }
                        }
                    }
                }
            }

            // --- Game Logic ---
            function movePaddle() {
                 // Handle keyboard movement
                 if (rightPressed && paddleX < canvas.width - paddleWidth) {
                    paddleX += 7;
                } else if (leftPressed && paddleX > 0) {
                    paddleX -= 7;
                }
                 // Pointer movement is handled by handlePointerMove directly updating paddleX
            }

            function moveBall() {
                // Wall collisions
                if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
                    dx = -dx;
                    playSound('C4', '32n', -10);
                }
                if (y + dy < ballRadius) {
                    dy = -dy;
                    playSound('C4', '32n', -10);
                }
                // Paddle/Bottom collision
                else if (y + dy > canvas.height - ballRadius - paddleHeight) {
                     if (x > paddleX && x < paddleX + paddleWidth && y + dy > canvas.height - ballRadius - paddleHeight) {
                         dy = -dy;
                         playSound('E4', '16n', -8);
                         let deltaX = x - (paddleX + paddleWidth/2);
                         dx = deltaX * 0.2;
                         dx = Math.max(-maxBallSpeed * 0.8, Math.min(maxBallSpeed * 0.8, dx));
                    } else if (y + dy > canvas.height - ballRadius) {
                         playSound('C3', '4n', 0);
                         showEndGameMessage("GAME OVER");
                    }
                }

                x += dx;
                y += dy;
            }

            function showEndGameMessage(message) {
                gameRunning = false;
                messageText.textContent = message;
                messageBox.style.display = 'block';
            }

            // --- Main Game Loop ---
            function draw() {
                if (!gameRunning) return;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBricks();
                drawBall();
                drawPaddle();
                collisionDetection();
                moveBall();
                movePaddle(); // Handles keyboard input

                requestAnimationFrame(draw);
            }

            // --- Initial Setup ---
            initGame(); // Initialize with calculated layout
            draw(); // Start the game loop

            // --- Optional: Resize handler to recalculate layout if window size changes ---
            // let resizeTimeout;
            // window.addEventListener('resize', () => {
            //     // Debounce resize event
            //     clearTimeout(resizeTimeout);
            //     resizeTimeout = setTimeout(() => {
            //         console.log("Resizing...");
            //         // Recalculate layout and potentially restart or adjust game state
            //         // For simplicity, we might just restart the game on resize
            //         initGame();
            //         // Note: A more complex solution would try to preserve game state
            //     }, 250); // Wait 250ms after resize stops
            // });

        };
    </script>
</body>
</html>
